{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nimport { useRef, useState, useCallback, useEffect } from 'react';\nimport { AsYouType, getCountryCallingCode, parseDigits } from 'libphonenumber-js/core';\nimport getInternationalPhoneNumberPrefix from './helpers/getInternationalPhoneNumberPrefix';\n/**\r\n * Returns `[phoneDigits, setPhoneDigits]`.\r\n * \"Phone digits\" includes not only \"digits\" but also a `+` sign.\r\n */\n\nexport default function usePhoneDigits(_ref) {\n  var value = _ref.value,\n      onChange = _ref.onChange,\n      country = _ref.country,\n      defaultCountry = _ref.defaultCountry,\n      international = _ref.international,\n      withCountryCallingCode = _ref.withCountryCallingCode,\n      useNationalFormatForDefaultCountryValue = _ref.useNationalFormatForDefaultCountryValue,\n      metadata = _ref.metadata;\n  var countryMismatchDetected = useRef();\n\n  var onCountryMismatch = function onCountryMismatch(value, country, actualCountry) {\n    console.error(\"[react-phone-number-input] Expected phone number \".concat(value, \" to correspond to country \").concat(country, \" but \").concat(actualCountry ? 'in reality it corresponds to country ' + actualCountry : 'it doesn\\'t', \".\"));\n    countryMismatchDetected.current = true;\n  };\n\n  var getInitialPhoneDigits = function getInitialPhoneDigits() {\n    return getPhoneDigitsForValue(value, country, international, withCountryCallingCode, defaultCountry, useNationalFormatForDefaultCountryValue, metadata, onCountryMismatch);\n  }; // This is only used to detect `country` property change.\n\n\n  var _useState = useState(country),\n      _useState2 = _slicedToArray(_useState, 2),\n      prevCountry = _useState2[0],\n      setPrevCountry = _useState2[1]; // This is only used to detect `defaultCountry` property change.\n\n\n  var _useState3 = useState(defaultCountry),\n      _useState4 = _slicedToArray(_useState3, 2),\n      prevDefaultCountry = _useState4[0],\n      setPrevDefaultCountry = _useState4[1]; // `phoneDigits` is the `value` passed to the `<input/>`.\n\n\n  var _useState5 = useState(getInitialPhoneDigits()),\n      _useState6 = _slicedToArray(_useState5, 2),\n      phoneDigits = _useState6[0],\n      setPhoneDigits = _useState6[1]; // This is only used to detect `value` property changes.\n\n\n  var _useState7 = useState(value),\n      _useState8 = _slicedToArray(_useState7, 2),\n      valueForPhoneDigits = _useState8[0],\n      setValueForPhoneDigits = _useState8[1]; // Rerender hack.\n\n\n  var _useState9 = useState(),\n      _useState10 = _slicedToArray(_useState9, 2),\n      rerenderTrigger = _useState10[0],\n      setRerenderTrigger = _useState10[1];\n\n  var rerender = useCallback(function () {\n    return setRerenderTrigger({});\n  }, [setRerenderTrigger]); // If `value` property has been changed externally\n  // then re-initialize the component.\n\n  useEffect(function () {\n    if (value !== valueForPhoneDigits) {\n      setValueForPhoneDigits(value);\n      setPhoneDigits(getInitialPhoneDigits());\n    }\n  }, [value]); // If the `country` has been changed then re-initialize the component.\n\n  useEffect(function () {\n    if (country !== prevCountry) {\n      setPrevCountry(country);\n      setPhoneDigits(getInitialPhoneDigits());\n    }\n  }, [country]); // If the `defaultCountry` has been changed then re-initialize the component.\n\n  useEffect(function () {\n    if (defaultCountry !== prevDefaultCountry) {\n      setPrevDefaultCountry(defaultCountry);\n      setPhoneDigits(getInitialPhoneDigits());\n    }\n  }, [defaultCountry]); // Update the `value` after `valueForPhoneDigits` has been updated.\n\n  useEffect(function () {\n    if (valueForPhoneDigits !== value) {\n      onChange(valueForPhoneDigits);\n    }\n  }, [valueForPhoneDigits]);\n  var onSetPhoneDigits = useCallback(function (phoneDigits) {\n    var value;\n\n    if (country) {\n      if (international && withCountryCallingCode) {\n        // The `<input/>` value must start with the country calling code.\n        var prefix = getInternationalPhoneNumberPrefix(country, metadata);\n\n        if (phoneDigits.indexOf(prefix) !== 0) {\n          // If a user tabs into a phone number input field\n          // that is `international` and `withCountryCallingCode`,\n          // and then starts inputting local phone number digits,\n          // the first digit would get \"swallowed\" if the fix below wasn't implemented.\n          // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n          if (phoneDigits && phoneDigits[0] !== '+') {\n            phoneDigits = prefix + phoneDigits;\n          } else {\n            // // Reset phone digits if they don't start with the correct prefix.\n            // // Undo the `<input/>` value change if it doesn't.\n            if (countryMismatchDetected.current) {// In case of a `country`/`value` mismatch,\n              // if it performed an \"undo\" here, then\n              // it wouldn't let a user edit their phone number at all,\n              // so this special case at least allows phone number editing\n              // when `value` already doesn't match the `country`.\n            } else {\n              // If it simply did `phoneDigits = prefix` here,\n              // then it could have no effect when erasing phone number\n              // via Backspace, because `phoneDigits` in `state` wouldn't change\n              // as a result, because it was `prefix` and it became `prefix`,\n              // so the component wouldn't rerender, and the user would be able\n              // to erase the country calling code part, and that part is\n              // assumed to be non-eraseable. That's why the component is\n              // forcefully rerendered here.\n              setPhoneDigits(prefix);\n              setValueForPhoneDigits(undefined); // Force a re-render of the `<input/>` with previous `phoneDigits` value.\n\n              return rerender();\n            }\n          }\n        }\n      } else {\n        // Entering phone number either in \"national\" format\n        // when `country` has been specified, or in \"international\" format\n        // when `country` has been specified but `withCountryCallingCode` hasn't.\n        // Therefore, `+` is not allowed.\n        if (phoneDigits && phoneDigits[0] === '+') {\n          // Remove the `+`.\n          phoneDigits = phoneDigits.slice(1);\n        }\n      }\n    } else if (!defaultCountry) {\n      // Force a `+` in the beginning of a `value`\n      // when no `country` and `defaultCountry` have been specified.\n      if (phoneDigits && phoneDigits[0] !== '+') {\n        // Prepend a `+`.\n        phoneDigits = '+' + phoneDigits;\n      }\n    } // Convert `phoneDigits` to `value`.\n\n\n    if (phoneDigits) {\n      var asYouType = new AsYouType(country || defaultCountry, metadata);\n      asYouType.input(country && international && !withCountryCallingCode ? \"+\".concat(getCountryCallingCode(country, metadata)).concat(phoneDigits) : phoneDigits);\n      var phoneNumber = asYouType.getNumber(); // If it's a \"possible\" incomplete phone number.\n\n      if (phoneNumber) {\n        value = phoneNumber.number;\n      }\n    }\n\n    setPhoneDigits(phoneDigits);\n    setValueForPhoneDigits(value);\n  }, [country, international, withCountryCallingCode, defaultCountry, metadata, setPhoneDigits, setValueForPhoneDigits, rerender, countryMismatchDetected]);\n  return [phoneDigits, onSetPhoneDigits];\n}\n/**\r\n * Returns phone number input field value for a E.164 phone number `value`.\r\n * @param  {string} [value]\r\n * @param  {string} [country]\r\n * @param  {boolean} [international]\r\n * @param  {boolean} [withCountryCallingCode]\r\n * @param  {string} [defaultCountry]\r\n * @param  {boolean} [useNationalFormatForDefaultCountryValue]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\n\nfunction getPhoneDigitsForValue(value, country, international, withCountryCallingCode, defaultCountry, useNationalFormatForDefaultCountryValue, metadata, onCountryMismatch) {\n  if (country && international && withCountryCallingCode) {\n    var prefix = getInternationalPhoneNumberPrefix(country, metadata);\n\n    if (value) {\n      if (value.indexOf(prefix) !== 0) {\n        onCountryMismatch(value, country);\n      }\n\n      return value;\n    }\n\n    return prefix;\n  }\n\n  if (!value) {\n    return '';\n  }\n\n  if (!country && !defaultCountry) {\n    return value;\n  }\n\n  var asYouType = new AsYouType(undefined, metadata);\n  asYouType.input(value);\n  var phoneNumber = asYouType.getNumber();\n\n  if (phoneNumber) {\n    if (country) {\n      if (phoneNumber.country && phoneNumber.country !== country) {\n        onCountryMismatch(value, country, phoneNumber.country);\n      } else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata)) {\n        onCountryMismatch(value, country);\n      }\n\n      if (international) {\n        return phoneNumber.nationalNumber;\n      }\n\n      return parseDigits(phoneNumber.formatNational());\n    } else {\n      // `phoneNumber.countryCallingCode` is compared here  instead of\n      // `phoneNumber.country`, because, for example, a person could have\n      // previously input a phone number (in \"national\" format) that isn't\n      // 100% valid for the `defaultCountry`, and if `phoneNumber.country`\n      // was compared, then it wouldn't match, and such phone number\n      // wouldn't be formatted as a \"national\" one, and instead would be\n      // formatted as an \"international\" one, confusing the user.\n      // Comparing `phoneNumber.countryCallingCode` works around such issues.\n      //\n      // Example: `defaultCountry=\"US\"` and the `<input/>` is empty.\n      // The user inputs: \"222 333 4444\", which gets formatted to \"(222) 333-4444\".\n      // The user then clicks \"Save\", the page is refreshed, and the user sees\n      // that the `<input/>` value is now \"+1 222 333 4444\" which confuses the user:\n      // the user expected the `<input/>` value to be \"(222) 333-4444\", same as it\n      // was when they've just typed it in. The cause of the issue is that \"222 333 4444\"\n      // is not a valid national number for US, and `phoneNumber.country` is compared\n      // instead of `phoneNumber.countryCallingCode`. After the `phoneNumber.country`\n      // comparison is replaced with `phoneNumber.countryCallingCode` one, the issue\n      // is no longer the case.\n      //\n      if (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata) && useNationalFormatForDefaultCountryValue) {\n        return parseDigits(phoneNumber.formatNational());\n      }\n\n      return value;\n    }\n  } else {\n    return '';\n  }\n}","map":{"version":3,"sources":["../source/usePhoneDigits.js"],"names":["value","onChange","country","defaultCountry","international","withCountryCallingCode","useNationalFormatForDefaultCountryValue","metadata","countryMismatchDetected","useRef","onCountryMismatch","console","actualCountry","getInitialPhoneDigits","getPhoneDigitsForValue","prevCountry","setPrevCountry","useState","prevDefaultCountry","setPrevDefaultCountry","phoneDigits","setPhoneDigits","valueForPhoneDigits","setValueForPhoneDigits","rerenderTrigger","setRerenderTrigger","rerender","useCallback","useEffect","onSetPhoneDigits","prefix","getInternationalPhoneNumberPrefix","asYouType","getCountryCallingCode","phoneNumber","parseDigits"],"mappings":"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","sourcesContent":["import { useRef, useState, useCallback, useEffect } from 'react'\r\nimport { AsYouType, getCountryCallingCode, parseDigits } from 'libphonenumber-js/core'\r\n\r\nimport getInternationalPhoneNumberPrefix from './helpers/getInternationalPhoneNumberPrefix'\r\n\r\n/**\r\n * Returns `[phoneDigits, setPhoneDigits]`.\r\n * \"Phone digits\" includes not only \"digits\" but also a `+` sign.\r\n */\r\nexport default function usePhoneDigits({\r\n\tvalue,\r\n\tonChange,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tinternational,\r\n\twithCountryCallingCode,\r\n\tuseNationalFormatForDefaultCountryValue,\r\n\tmetadata\r\n}) {\r\n\tconst countryMismatchDetected = useRef()\r\n\tconst onCountryMismatch = (value, country, actualCountry) => {\r\n\t\tconsole.error(`[react-phone-number-input] Expected phone number ${value} to correspond to country ${country} but ${actualCountry ? 'in reality it corresponds to country ' + actualCountry : 'it doesn\\'t'}.`)\r\n\t\tcountryMismatchDetected.current = true\r\n\t}\r\n\tconst getInitialPhoneDigits = () => getPhoneDigitsForValue(\r\n\t\tvalue,\r\n\t\tcountry,\r\n\t\tinternational,\r\n\t\twithCountryCallingCode,\r\n\t\tdefaultCountry,\r\n\t\tuseNationalFormatForDefaultCountryValue,\r\n\t\tmetadata,\r\n\t\tonCountryMismatch\r\n\t)\r\n\t// This is only used to detect `country` property change.\r\n\tconst [prevCountry, setPrevCountry] = useState(country)\r\n\t// This is only used to detect `defaultCountry` property change.\r\n\tconst [prevDefaultCountry, setPrevDefaultCountry] = useState(defaultCountry)\r\n\t// `phoneDigits` is the `value` passed to the `<input/>`.\r\n\tconst [phoneDigits, setPhoneDigits] = useState(getInitialPhoneDigits())\r\n\t// This is only used to detect `value` property changes.\r\n\tconst [valueForPhoneDigits, setValueForPhoneDigits] = useState(value)\r\n\t// Rerender hack.\r\n\tconst [rerenderTrigger, setRerenderTrigger] = useState()\r\n\tconst rerender = useCallback(() => setRerenderTrigger({}), [setRerenderTrigger])\r\n\t// If `value` property has been changed externally\r\n\t// then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (value !== valueForPhoneDigits) {\r\n\t\t\tsetValueForPhoneDigits(value)\r\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\r\n\t\t}\r\n\t}, [value])\r\n\t// If the `country` has been changed then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (country !== prevCountry) {\r\n\t\t\tsetPrevCountry(country)\r\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\r\n\t\t}\r\n\t}, [country])\r\n\t// If the `defaultCountry` has been changed then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (defaultCountry !== prevDefaultCountry) {\r\n\t\t\tsetPrevDefaultCountry(defaultCountry)\r\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\r\n\t\t}\r\n\t}, [defaultCountry])\r\n\t// Update the `value` after `valueForPhoneDigits` has been updated.\r\n\tuseEffect(() => {\r\n\t\tif (valueForPhoneDigits !== value) {\r\n\t\t\tonChange(valueForPhoneDigits)\r\n\t\t}\r\n\t}, [valueForPhoneDigits])\r\n\tconst onSetPhoneDigits = useCallback((phoneDigits) => {\r\n\t\tlet value\r\n\t\tif (country) {\r\n\t\t\tif (international && withCountryCallingCode) {\r\n\t\t\t\t// The `<input/>` value must start with the country calling code.\r\n\t\t\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\t\t\t\tif (phoneDigits.indexOf(prefix) !== 0) {\r\n\t\t\t\t\t// If a user tabs into a phone number input field\r\n\t\t\t\t\t// that is `international` and `withCountryCallingCode`,\r\n\t\t\t\t\t// and then starts inputting local phone number digits,\r\n\t\t\t\t\t// the first digit would get \"swallowed\" if the fix below wasn't implemented.\r\n\t\t\t\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\r\n\t\t\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\r\n\t\t\t\t\t\tphoneDigits = prefix + phoneDigits\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// // Reset phone digits if they don't start with the correct prefix.\r\n\t\t\t\t\t\t// // Undo the `<input/>` value change if it doesn't.\r\n\t\t\t\t\t\tif (countryMismatchDetected.current) {\r\n\t\t\t\t\t\t\t// In case of a `country`/`value` mismatch,\r\n\t\t\t\t\t\t\t// if it performed an \"undo\" here, then\r\n\t\t\t\t\t\t\t// it wouldn't let a user edit their phone number at all,\r\n\t\t\t\t\t\t\t// so this special case at least allows phone number editing\r\n\t\t\t\t\t\t\t// when `value` already doesn't match the `country`.\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// If it simply did `phoneDigits = prefix` here,\r\n\t\t\t\t\t\t\t// then it could have no effect when erasing phone number\r\n\t\t\t\t\t\t\t// via Backspace, because `phoneDigits` in `state` wouldn't change\r\n\t\t\t\t\t\t\t// as a result, because it was `prefix` and it became `prefix`,\r\n\t\t\t\t\t\t\t// so the component wouldn't rerender, and the user would be able\r\n\t\t\t\t\t\t\t// to erase the country calling code part, and that part is\r\n\t\t\t\t\t\t\t// assumed to be non-eraseable. That's why the component is\r\n\t\t\t\t\t\t\t// forcefully rerendered here.\r\n\t\t\t\t\t\t\tsetPhoneDigits(prefix)\r\n\t\t\t\t\t\t\tsetValueForPhoneDigits(undefined)\r\n\t\t\t\t\t\t\t// Force a re-render of the `<input/>` with previous `phoneDigits` value.\r\n\t\t\t\t\t\t\treturn rerender()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Entering phone number either in \"national\" format\r\n\t\t\t\t// when `country` has been specified, or in \"international\" format\r\n\t\t\t\t// when `country` has been specified but `withCountryCallingCode` hasn't.\r\n\t\t\t\t// Therefore, `+` is not allowed.\r\n\t\t\t\tif (phoneDigits && phoneDigits[0] === '+') {\r\n\t\t\t\t\t// Remove the `+`.\r\n\t\t\t\t\tphoneDigits = phoneDigits.slice(1)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (!defaultCountry) {\r\n\t\t\t// Force a `+` in the beginning of a `value`\r\n\t\t\t// when no `country` and `defaultCountry` have been specified.\r\n\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\r\n\t\t\t\t// Prepend a `+`.\r\n\t\t\t\tphoneDigits = '+' + phoneDigits\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Convert `phoneDigits` to `value`.\r\n\t\tif (phoneDigits) {\r\n\t\t\tconst asYouType = new AsYouType(country || defaultCountry, metadata)\r\n\t\t\tasYouType.input(\r\n\t\t\t\tcountry && international && !withCountryCallingCode ?\r\n\t\t\t\t`+${getCountryCallingCode(country, metadata)}${phoneDigits}` :\r\n\t\t\t\tphoneDigits\r\n\t\t\t)\r\n\t\t\tconst phoneNumber = asYouType.getNumber()\r\n\t\t\t// If it's a \"possible\" incomplete phone number.\r\n\t\t\tif (phoneNumber) {\r\n\t\t\t\tvalue = phoneNumber.number\r\n\t\t\t}\r\n\t\t}\r\n\t\tsetPhoneDigits(phoneDigits)\r\n\t\tsetValueForPhoneDigits(value)\r\n\t}, [\r\n\t\tcountry,\r\n\t\tinternational,\r\n\t\twithCountryCallingCode,\r\n\t\tdefaultCountry,\r\n\t\tmetadata,\r\n\t\tsetPhoneDigits,\r\n\t\tsetValueForPhoneDigits,\r\n\t\trerender,\r\n\t\tcountryMismatchDetected\r\n\t])\r\n\treturn [\r\n\t\tphoneDigits,\r\n\t\tonSetPhoneDigits\r\n\t]\r\n}\r\n\r\n/**\r\n * Returns phone number input field value for a E.164 phone number `value`.\r\n * @param  {string} [value]\r\n * @param  {string} [country]\r\n * @param  {boolean} [international]\r\n * @param  {boolean} [withCountryCallingCode]\r\n * @param  {string} [defaultCountry]\r\n * @param  {boolean} [useNationalFormatForDefaultCountryValue]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nfunction getPhoneDigitsForValue(\r\n\tvalue,\r\n\tcountry,\r\n\tinternational,\r\n\twithCountryCallingCode,\r\n\tdefaultCountry,\r\n\tuseNationalFormatForDefaultCountryValue,\r\n\tmetadata,\r\n\tonCountryMismatch\r\n) {\r\n\tif (country && international && withCountryCallingCode) {\r\n\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\t\tif (value) {\r\n\t\t\tif (value.indexOf(prefix) !== 0) {\r\n\t\t\t\tonCountryMismatch(value, country)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\treturn prefix\r\n\t}\r\n\tif (!value) {\r\n\t\treturn ''\r\n\t}\r\n\tif (!country && !defaultCountry) {\r\n\t\treturn value\r\n\t}\r\n\tconst asYouType = new AsYouType(undefined, metadata)\r\n\tasYouType.input(value)\r\n\tconst phoneNumber = asYouType.getNumber()\r\n\tif (phoneNumber) {\r\n\t\tif (country) {\r\n\t\t\tif (phoneNumber.country && phoneNumber.country !== country) {\r\n\t\t\t\tonCountryMismatch(value, country, phoneNumber.country)\r\n\t\t\t} else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata)) {\r\n\t\t\t\tonCountryMismatch(value, country)\r\n\t\t\t}\r\n\t\t\tif (international) {\r\n\t\t\t\treturn phoneNumber.nationalNumber\r\n\t\t\t}\r\n\t\t\treturn parseDigits(phoneNumber.formatNational())\r\n\t\t} else {\r\n\t\t\t// `phoneNumber.countryCallingCode` is compared here  instead of\r\n\t\t\t// `phoneNumber.country`, because, for example, a person could have\r\n\t\t\t// previously input a phone number (in \"national\" format) that isn't\r\n\t\t\t// 100% valid for the `defaultCountry`, and if `phoneNumber.country`\r\n\t\t\t// was compared, then it wouldn't match, and such phone number\r\n\t\t\t// wouldn't be formatted as a \"national\" one, and instead would be\r\n\t\t\t// formatted as an \"international\" one, confusing the user.\r\n\t\t\t// Comparing `phoneNumber.countryCallingCode` works around such issues.\r\n\t\t\t//\r\n\t\t\t// Example: `defaultCountry=\"US\"` and the `<input/>` is empty.\r\n\t\t\t// The user inputs: \"222 333 4444\", which gets formatted to \"(222) 333-4444\".\r\n\t\t\t// The user then clicks \"Save\", the page is refreshed, and the user sees\r\n\t\t\t// that the `<input/>` value is now \"+1 222 333 4444\" which confuses the user:\r\n\t\t\t// the user expected the `<input/>` value to be \"(222) 333-4444\", same as it\r\n\t\t\t// was when they've just typed it in. The cause of the issue is that \"222 333 4444\"\r\n\t\t\t// is not a valid national number for US, and `phoneNumber.country` is compared\r\n\t\t\t// instead of `phoneNumber.countryCallingCode`. After the `phoneNumber.country`\r\n\t\t\t// comparison is replaced with `phoneNumber.countryCallingCode` one, the issue\r\n\t\t\t// is no longer the case.\r\n\t\t\t//\r\n\t\t\tif (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata) && useNationalFormatForDefaultCountryValue) {\r\n\t\t\t\treturn parseDigits(phoneNumber.formatNational())\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t} else {\r\n\t\treturn ''\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}